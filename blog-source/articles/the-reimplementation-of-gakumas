---
publicId: the-reimplementation-of-gakumas
lastUpdatedAt: 2024-12-09 09:00:00+0900
---

# 学マスのカードゲーム部分の実装を再現した話

学マスというゲームの再現実装をしたので、その作業中に感じた開発ノウハウを話す内容です。

## 学マスとは？

[学園アイドルマスター](https://gakuen.idolmaster-official.jp/)というバンナムが運営している、いわゆるカジュアルスマホゲーム・ソーシャルゲームです。

2024/05/16にリリースしており、初日にプレイして出来の良さにびっくりしてバンナムの株を買ったほどです。別段上がってないです。

おおよそのゲーム性は、デッキ構築型のカードゲームと、パワプロのサクセス部分もしくはウマ娘の育成ゲーム部分の組み合わせです。

## なぜ再現実装をしたの？

一言で言うと、趣味だから・楽しいからです。

もう少し解説すると、自身のキャリアや時代の変化により、仕事で答えのあるロジックをプログラミングをする量が減少しており、時折無性にロジックとテストコードを交互に書くような作業がしたくなることがあります。その題材として、既存のゲームの再現を選んでいます。

他には、直近の完成品だと[ローゼンケーニッヒというボードゲームの再現](https://github.com/kjirou/rosenkoenig-core)を書きました。また、途中で学マスへ切り替えてしまいましたが、[ポケカの再現をしようとして初手のデータモデリングで止まって](https://github.com/kjirou/pokemon-tcg-core/pull/3)ます。exスタートデッキの範疇でも中々複雑で、TCGの闇を知った気がします。

また、単に感銘したモノに対しての推し心の発露という側面もあります。なんかしたくなる。

## 再現実装のこと

関連リポジトリは以下です。

- [kjirou/gakumas-core](https://github.com/kjirou/gakumas-core)
- [kjirou/gakumas-lesson-simulator](https://github.com/kjirou/gakumas-lesson-simulator)

gakumas-coreは、TypeScript製のPure JavaScriptのコードです。ゲームロジックを表現したデータ構造と関数の集合です。gakumas-lesson-simulatorは、UIへ反映する検証をゲームのシミュレーターという形で表現するための[Gatsby](https://www.gatsbyjs.com/)の実装で、今回の話にはあまり関係ありません。

再現したのはデッキ構築型カードバトル部分のみで、育成ゲーム部分は含みません。プレイヤーから見てゲームの研究対象になるのは主に育成ゲーム部分であり、全く世間の需要を満たしていない実装でもあります。

2024/09/22にマージした[【Feel Jewel Dream】有村麻央を追加](https://github.com/kjirou/gakumas-core/pull/253)が最後のプルリクエストで、それ以後は残念ながらゲームへの興味を失ってしまったので、追随していません。プレイヤーとしての現状はログボ勢です。アノマリーって何ですか？

## 感じた開発ノウハウ

はじめにおことわりですが、自分はゲーム作成のプロどころかアマチュアですらなく、そちらの経験はほぼありません。10年前くらいに2本程度JSである程度の大きさのゲームを作っていますが、過去の話です。どちらかというと、Webフロントエンド開発者もしくはWebプログラマとしての見解です。

### 状態の更新は間にイベントを介して表現すると良かった

例えば、ライフへ5ダメージを与えることを、以下のようなイベントを作成して表現しました。

```js
const ライフを5減少するイベント = {
  type: "life",
  value: -5,
};
```

加えて、別にイベントリストを集計して現在値を算出する処理を作成し、各種状態の現在値の算出はこの関数を介して行いました。イベントリストは、ゲームの開始から終了までの発行したイベント全てを保持します。

```js
const 各種現在値を算出する = (初期値, イベントリスト) => {
  let 現在値 = 初期値;
  for (const イベント of イベントリスト) {
    switch (イベント.type) {
      case "life": {
        現在値 = {
          ...現在値,
          life: 現在値.life + イベント.life,
        };
      }
    }
  }
  return 現在値;
};
```

特に事情がない場合は、以下のように現在値を減少すると思うのですが、それと比較して何が良かったのか、という話です。

```js
const 新しい現在値 = {
  ...現在値,
  life: 現在値.life - 5,
};
```

良かったと実感した点は、2点ありました。

ひとつめは、状態の変化を直接抽出できるため、テストコードのアサーションの期待値が明確になることです。例えば、「5ダメージ発生した」というテストケースを書く場合に、イベントの5の値を期待値として使うことができます。現在値を修正する方式の場合は、変化前の現在値から変化後の現在値を差し引くことでしかその差がわかりません。単純な加減算の計算しか発生しないなら問題は少ないですが、ゲームによっては、1回の攻撃で複数回ダメージが発生したり、毒や混乱などの何らかの効果を付与するようなものもあります。それらのデータ構造は辞書やリストで表現されるようなより複雑なものなので、差し引きによる変化の抽出が困難または不可能です。

ふたつめは、イベントリストをUIへ渡すと、アニメーション等に使える簡易的な状態変化の明細になることです。例えば、ライフが20のキャラクターが5ダメージを受けて15になった場合に、ほとんどの状況ではUIへ15の値だけ渡しても情報が足りません。5ダメージは何らかの概念により2と3に分割して発生したかもしれないし、色味をつけるために炎や氷属性などの属性情報が必要かもしれません。そういった情報をUIへ渡すために、イベントリストがそのまま使えます。もちろん、計算時にアニメーション用の専用のイベントを出力するのが正攻法ですが、複雑なデータ構造を増やすのは手間が大きいです。これはゲーム作成経験のない人の主観ですが、デッキ構築型カードゲーム程度に見た目の動きの少ないゲームなら、ロジックの都合で生成されたイベントリストでもおおよそ足りるのではないかと思っています。ちなみに、これにより、古今東西のゲームでよくある「すごいダメージの攻撃をしたのに、敵の体力を減らした分までしかダメージ量が表示されない」問題が解決します。

一方で、悪そうな点も、2点あります。

ひとつめは、現在値の算出にイベントリストを集計する必要があるので、処理が遅くなりそうなことです。物凄く雑にデッキ構築型で1戦闘で発生しそうなイベント数を試算してみると、「4キャラクター（プレイヤー+敵3体） \* 10ターン \* 10イベント/行動 = 400イベント」程度なので、集計処理の複雑さ次第でもありますが、問題になる計算量ではなさそうです。

ふたつめは、イベントの概念が増え、集計処理が必要になることで、実装が複雑になり見通しが悪くなることです。これは一定の影響はあると思っています。例えば、ReduxのActionを介した状態の更新に似た影響があるでしょう。

悪い点もありますが、総じて良かったと思いました。

この設計は、イベントソーシング設計の一側面に似ています。イベントソーシング自体は多くの問題を視野に入れた設計ですが、単一システムかつオンメモリな状況でも役立つものですねという所感です。
